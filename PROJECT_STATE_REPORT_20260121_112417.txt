========================================
STAR WORKFORCE SOLUTIONS - STATE AUDIT
========================================
Generated: Wed Jan 21 11:24:17 CST 2026

========================================
SECTION 1: GIT STATUS
========================================

Current Branch:
main

Last 5 Commits:
d9e17b5 Fix schema: Sync with database structure via introspection
6ca01fd fix: Downgrade to Prisma 6 & add schema
5df1092 fix: Add all missing dependencies for Vercel deployment
3e66c95 fix: Add missing dependencies and Prisma client
24b0023 feat: Phase 1 - Critical Auth Fixes & Dashboards

Uncommitted Changes:
 D src/app/hire-recruiter/HireRecruiterClient.tsx
 D src/app/hire-recruiter/page.tsx
 D test-results-20260116-210130.log
 D test-results-20260116-215707.log
?? PROJECT_STATE_REPORT_20260121_112417.txt
?? prisma/schema.prisma.backup.20260117-221450
?? prisma/schema.prisma.fixed.20260117-223559
?? prisma/schema.prisma.introspected.20260117-223559
?? prisma/schema.prisma.original.20260117-223559

========================================
SECTION 2: API ROUTES STRUCTURE
========================================

Contents of app/api/:
app/api/ats-export-pdf/route.ts
app/api/ats-free/route.ts
app/api/ats-full/route.ts
app/api/ats-purchase/route.ts
app/api/ats-restore/route.ts
app/api/ats-success/route.ts
app/api/ats-upload/route.ts
app/api/auth/[...nextauth]/route.ts
app/api/auth/forgot-password/route.ts
app/api/auth/register/route.ts
app/api/auth/reset-password/route.ts
app/api/checkout/guest/route.ts
app/api/checkout/subscription/route.ts
app/api/contact/route.ts
app/api/cover-letter-export-pdf/route.ts
app/api/cover-letter-free/route.ts
app/api/cover-letter-full/route.ts
app/api/cover-letter-purchase/route.ts
app/api/cover-letter-restore/route.ts
app/api/cover-letter-upload/route.ts
app/api/cron/expire-jobs/route.ts
app/api/dashboard/applications/route.ts
app/api/dashboard/saved-jobs/route.ts
app/api/dashboard/stats/route.ts
app/api/employer/jobs/create/route.ts
app/api/employer/register/route.ts
app/api/guest/verify-token/route.ts
app/api/health/route.ts
app/api/interview-prep-start/route.ts
app/api/interview-prep-submit/route.ts
app/api/jobs/[id]/deactivate/route.ts
app/api/jobs/apply/route.ts
app/api/jobs/create/route.ts
app/api/jobs/employer/list/route.ts
app/api/jobs/list/route.ts
app/api/jobs/save/route.ts
app/api/jobs/search/route.ts
app/api/stripe/checkout/route.ts
app/api/stripe/webhook/route.ts
app/api/upload/resume/route.ts
app/api/user/profile/route.ts
app/api/user/resumes/route.ts
app/api/validate-stripe-env/route.ts

========================================
SECTION 3: STRIPE API ROUTES DETAIL
========================================

Files in app/api/stripe/:
total 8
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 13 18:01 .
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 16 20:40 ..
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 13 18:01 checkout
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 16 20:47 webhook

--- app/api/stripe/checkout/route.ts ---
import { type NextRequest, NextResponse } from "next/server"
import { createCheckoutSession, STRIPE_PRODUCTS } from "@/lib/stripe"
import { getCurrentUser } from "@/lib/session"

// POST /api/stripe/checkout
// Creates a Stripe checkout session for ATS Optimizer or subscription

export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser()

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const body = await request.json()
    const { product } = body

    // Validate product
    if (!product || !(product in STRIPE_PRODUCTS)) {
      return NextResponse.json({ error: "Invalid product" }, { status: 400 })
    }

    const baseUrl = process.env.NEXT_PUBLIC_URL || "http://localhost:3000"

    // Create checkout session
    const session = await createCheckoutSession({
      userId: user.id,
      productKey: product as keyof typeof STRIPE_PRODUCTS,
      successUrl: `${baseUrl}/payment/success?session_id={CHECKOUT_SESSION_ID}`,
      cancelUrl: `${baseUrl}/payment/cancel`,
    })

    return NextResponse.json({
      sessionId: session.id,
      url: session.url,
    })
  } catch (error) {
    console.error("[v0] Error creating checkout session:", error)
    return NextResponse.json({ error: "Failed to create checkout session" }, { status: 500 })
  }
}

[truncated...]

--- app/api/stripe/webhook/route.ts ---
import { type NextRequest, NextResponse } from "next/server"
import Stripe from "stripe"
import { sql } from "@vercel/postgres"
import { neon } from "@neondatabase/serverless"

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || "", {
  apiVersion: "2024-11-20.acacia",
})

const sqlNeon = neon(process.env.DATABASE_URL!)

// Legacy price IDs (keep for backward compatibility)
const ATS_PRICE_ID = "price_1SVd4E04KnTBJoOrBcQTH6T5"
const COVER_LETTER_PRICE_ID = "price_1SWUhp04KnTBJoOrG8W8C8OK"

// New Phase 1 price IDs
const NEW_PRICE_IDS = {
  ATS_OPTIMIZER: process.env.STRIPE_PRICE_ATS_OPTIMIZER!,
  COVER_LETTER: process.env.STRIPE_PRICE_COVER_LETTER!,
  RESUME_DISTRIBUTION: process.env.STRIPE_PRICE_RESUME_DISTRIBUTION!,
  DIY_PREMIUM: process.env.STRIPE_PRICE_DIY_PREMIUM!,
  RECRUITER_BASIC: process.env.STRIPE_PRICE_RECRUITER_BASIC!,
  RECRUITER_STANDARD: process.env.STRIPE_PRICE_RECRUITER_STANDARD!,
  RECRUITER_PRO: process.env.STRIPE_PRICE_RECRUITER_PRO!,
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.text()
    const signature = request.headers.get("stripe-signature")

    if (!signature) {
      return NextResponse.json({ error: "Missing stripe-signature header" }, { status: 400 })
    }

    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!
    const event = stripe.webhooks.constructEvent(body, signature, webhookSecret)

    console.log("[WEBHOOK] Event type:", event.type)

    switch (event.type) {
      case "checkout.session.completed": {
        const session = event.data.object as Stripe.Checkout.Session

        const customerEmail = session.customer_email || session.metadata?.email
        const resumeId = session.metadata?.resumeId
        const coverLetterId = session.metadata?.coverLetterId

        if (!customerEmail) {
          console.error("[WEBHOOK] No customer email in session")

[truncated...]


========================================
SECTION 4: CHECKOUT & PAYMENT ROUTES
========================================

Files in app/api/checkout/:
total 8
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 16 20:40 .
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 16 20:40 ..
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 16 20:40 guest
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 16 20:40 subscription
--- app/api/checkout/guest/route.ts ---
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { neon } from '@neondatabase/serverless';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-11-20.acacia',
});

const sql = neon(process.env.DATABASE_URL!);

const GUEST_PURCHASE_TYPES = {
  ats_optimizer: {
    priceId: process.env.STRIPE_PRICE_ATS_OPTIMIZER!,
    name: 'ATS Optimizer',
    amount: 500,
  },
  cover_letter: {
    priceId: process.env.STRIPE_PRICE_COVER_LETTER!,
    name: 'Cover Letter Generator',
    amount: 500,
  },
  resume_distribution: {
    priceId: process.env.STRIPE_PRICE_RESUME_DISTRIBUTION!,
    name: 'Resume Distribution',
    amount: 14900,
  },
} as const;

type GuestPurchaseType = keyof typeof GUEST_PURCHASE_TYPES;

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { email, purchaseType, metadata } = body;

    if (!email || !purchaseType) {
      return NextResponse.json(
        { error: 'Email and purchase type are required' },
        { status: 400 }
      );
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return NextResponse.json(
        { error: 'Invalid email format' },
        { status: 400 }
      );
    }

    if (!GUEST_PURCHASE_TYPES[purchaseType as GuestPurchaseType]) {
      return NextResponse.json(
        { error: 'Invalid purchase type' },
        { status: 400 }
      );
    }

    const purchaseInfo = GUEST_PURCHASE_TYPES[purchaseType as GuestPurchaseType];

    const existingPurchase = await sql`
      SELECT id FROM guest_purchases 
      WHERE email = ${email} 
      AND purchase_type = ${purchaseType}
      AND created_at > NOW() - INTERVAL '1 year'
      LIMIT 1
    `;

    if (existingPurchase.length > 0) {
      return NextResponse.json(
        { 
          error: 'You already have access to this service',
          existingPurchase: true,
        },
        { status: 400 }
      );
    }

    // FIX: Only use customer_email, not both customer and customer_email
    const session = await stripe.checkout.sessions.create({
      line_items: [
        {
          price: purchaseInfo.priceId,
          quantity: 1,
        },
      ],
      mode: 'payment',
      success_url: `${process.env.NEXT_PUBLIC_URL}/payment/success?session_id={CHECKOUT_SESSION_ID}&guest=true`,
      cancel_url: `${process.env.NEXT_PUBLIC_URL}/payment/canceled`,
      customer_email: email,
      metadata: {
        email: email,
        purchase_type: purchaseType,
        user_type: 'guest',
        ...metadata,
      },
      payment_intent_data: {
        metadata: {
          email: email,
          purchase_type: purchaseType,
          user_type: 'guest',
        },
      },
    });

    return NextResponse.json({
      sessionId: session.id,
      url: session.url,
    });

  } catch (error: any) {
    console.error('Error creating guest checkout session:', error);
    return NextResponse.json(
      { error: 'Failed to create checkout session', details: error.message },
      { status: 500 }
    );
  }
}

--- app/api/checkout/subscription/route.ts ---
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { getServerSession } from 'next-auth';
import { neon } from '@neondatabase/serverless';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-11-20.acacia',
});

const sql = neon(process.env.DATABASE_URL!);

const SUBSCRIPTION_PRICES: Record<string, string> = {
  diy_premium: process.env.STRIPE_PRICE_DIY_PREMIUM!,
  recruiter_basic: process.env.STRIPE_PRICE_RECRUITER_BASIC!,
  recruiter_standard: process.env.STRIPE_PRICE_RECRUITER_STANDARD!,
  recruiter_pro: process.env.STRIPE_PRICE_RECRUITER_PRO!,
};

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession();
    
    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const { subscriptionType } = await req.json();
    
    if (!SUBSCRIPTION_PRICES[subscriptionType]) {
      return NextResponse.json(
        { error: 'Invalid subscription type' },
        { status: 400 }
      );
    }

    const users = await sql`
      SELECT id, email, stripe_customer_id 
      FROM users 
      WHERE email = ${session.user.email}
      LIMIT 1
    `;

    if (users.length === 0) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    const user = users[0];
    let customerId = user.stripe_customer_id;
    
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: user.email,
        metadata: {
          user_id: user.id,
        },
      });
      customerId = customer.id;
      
      await sql`
        UPDATE users 
        SET stripe_customer_id = ${customerId}
        WHERE id = ${user.id}
      `;
    }

    const checkoutSession = await stripe.checkout.sessions.create({
      customer: customerId,
      line_items: [
        {
          price: SUBSCRIPTION_PRICES[subscriptionType],
          quantity: 1,
        },
      ],
      mode: 'subscription',
      success_url: `${process.env.NEXT_PUBLIC_URL}/dashboard?success=true&session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.NEXT_PUBLIC_URL}/hire-recruiter`,
      metadata: {
        user_id: user.id,
        subscription_type: subscriptionType,
      },
      subscription_data: {
        metadata: {
          user_id: user.id,
          subscription_type: subscriptionType,
        },
      },
    });

    return NextResponse.json({
      sessionId: checkoutSession.id,
      url: checkoutSession.url,
    });

  } catch (error: any) {
    console.error('Subscription checkout error:', error);
    return NextResponse.json(
      { error: 'Failed to create checkout session', details: error.message },
      { status: 500 }
    );
  }
}


========================================
SECTION 5: GUEST PURCHASE ROUTES
========================================

Files in app/api/guest/:
total 8
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 16 22:05 .
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 16 20:40 ..
drwxr-xr-x 1 STAR Workforce 197121 0 Jan 16 22:05 verify-token

========================================
SECTION 6: AUTH ROUTES
========================================

Files in app/api/auth/:
app/api/auth/[...nextauth]/route.ts
app/api/auth/forgot-password/route.ts
app/api/auth/register/route.ts
app/api/auth/reset-password/route.ts

========================================
SECTION 7: LIB FILES
========================================

Contents of lib/:
total 83
drwxr-xr-x 1 STAR Workforce 197121    0 Jan 17 19:39 .
drwxr-xr-x 1 STAR Workforce 197121    0 Jan 21 11:24 ..
-rw-r--r-- 1 STAR Workforce 197121  993 Jan 13 18:01 analytics.ts
-rw-r--r-- 1 STAR Workforce 197121 4917 Jan 17 19:35 auth-config.ts
-rw-r--r-- 1 STAR Workforce 197121 5487 Jan 13 18:01 auth.ts
-rw-r--r-- 1 STAR Workforce 197121 6468 Jan 13 18:01 db.ts
drwxr-xr-x 1 STAR Workforce 197121    0 Jan 16 20:40 email-templates
-rw-r--r-- 1 STAR Workforce 197121 1398 Jan 13 18:01 monitoring.ts
-rw-r--r-- 1 STAR Workforce 197121  364 Jan 17 19:39 prisma.ts
-rw-r--r-- 1 STAR Workforce 197121 1953 Jan 13 18:01 rate-limit.ts
-rw-r--r-- 1 STAR Workforce 197121  699 Jan 16 20:40 send-email.ts
-rw-r--r-- 1 STAR Workforce 197121  610 Jan 13 18:01 session.ts
drwxr-xr-x 1 STAR Workforce 197121    0 Jan 16 20:40 stripe
-rw-r--r-- 1 STAR Workforce 197121 2061 Jan 13 18:01 stripe.ts
-rw-r--r-- 1 STAR Workforce 197121  166 Jan 13 18:01 utils.ts

========================================
SECTION 8: DASHBOARD PAGES
========================================

Dashboard structure:
app/api/dashboard
app/dashboard
app/employer/dashboard
app/guest-dashboard
app/recruiter/dashboard
app/dashboard/admin/page.tsx
app/dashboard/analytics/page.tsx
app/dashboard/job-seeker/page.tsx
app/dashboard/page.tsx
app/dashboard/recruiter/page.tsx
app/employer/dashboard/page.tsx
app/guest-dashboard/page.tsx

========================================
SECTION 9: HIRE RECRUITER PAGE
========================================

--- app/hire-recruiter/page.tsx (first 100 lines) ---
'use client';

import { useState } from 'react';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';

export default function HireRecruiter() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  const plans = [
    {
      name: 'Basic Plan',
      price: '$199',
      period: '/month',
      description: '3-5 daily job applications',
      features: [
        '3-5 targeted applications per day',
        'Resume optimization',
        'Cover letter customization',
        'Weekly progress reports',
        'Email support'
      ],
      subscriptionType: 'recruiter_basic'
    },
    {
      name: 'Standard Plan',
      price: '$399',
      period: '/month',
      description: '10-15 daily job applications',
      features: [
        '10-15 targeted applications per day',
        'Advanced resume optimization',
        'Custom cover letters',
        'Bi-weekly strategy calls',
        'Priority email support',
        'Interview preparation'
      ],
      subscriptionType: 'recruiter_standard',
      popular: true
    },
    {
      name: 'Pro Plan',
      price: '$599',
      period: '/month',
      description: '20-30 daily job applications',
      features: [
        '20-30 targeted applications per day',
        'Premium resume optimization',
        'Personalized cover letters',
        'Weekly strategy calls',
        'Priority phone support',
        'Interview coaching',
        'Salary negotiation support'
      ],
      subscriptionType: 'recruiter_pro'
    }
  ];

  const handleSelectPlan = async (subscriptionType: string) => {
    if (!session) {
      router.push(`/auth/login?callbackUrl=/hire-recruiter`);
      return;
    }

    setLoading(true);

    try {
      const response = await fetch('/api/checkout/subscription', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ subscriptionType }),
      });

      const data = await response.json();

      if (data.url) {
        window.location.href = data.url;
      } else {
        alert('Failed to create checkout session');
        setLoading(false);
      }
    } catch (error) {
      console.error('Checkout error:', error);
      alert('An error occurred');
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-[#0A1A2F] to-[#132A47] text-white">
      <div className="max-w-7xl mx-auto px-4 py-16">
        <div className="text-center mb-16">
          <h1 className="text-5xl font-bold mb-4">
            Hire Your <span className="text-[#E8C547]">Dedicated Offshore Recruiter</span>
          </h1>
          <p className="text-xl text-gray-300 max-w-3xl mx-auto">

========================================
SECTION 10: MIDDLEWARE
========================================

--- middleware.ts ---
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

const BAD_BOTS = [
  "GPTBot",
  "ClaudeBot",
  "Bytespider",
  "OmnaiBot",
  "SemrushBot",
  "AhrefsBot",
  "Dotbot",
  "MJ12bot",
  "PetalBot",
]

const GOOD_BOTS = [
  "Googlebot",
  "Bingbot",
  "Slurp",
  "DuckDuckBot",
  "Baiduspider",
  "facebookexternalhit",
  "LinkedInBot",
  "TwitterBot",
  "WhatsApp",
]

function isBot(userAgent: string): boolean {
  const ua = userAgent.toLowerCase()

  // Allow good bots
  if (GOOD_BOTS.some((bot) => ua.includes(bot.toLowerCase()))) {
    return false
  }

  // Block bad bots - exact match from robots.txt
  if (BAD_BOTS.some((bot) => ua.includes(bot.toLowerCase()))) {
    return true
  }

  return false
}

function isSuspiciousTraffic(request: NextRequest): boolean {
  const userAgent = request.headers.get("user-agent") || ""

  // No user agent or very short
  if (!userAgent || userAgent.length < 10) {
    return true
  }

  // Check for bot
  if (isBot(userAgent)) {
    return true
  }

  const hasAcceptLanguage = request.headers.has("accept-language")
  const hasAccept = request.headers.has("accept")
  const hasReferer = request.headers.has("referer")

  // Block only if missing ALL common headers
  if (!hasAcceptLanguage && !hasAccept && !hasReferer) {
    return true
  }

  return false
}

export function middleware(request: NextRequest) {
  const startTime = Date.now()

  const hostname = request.headers.get("host") || ""
  const url = request.nextUrl.clone()

  // Redirect starworkforcesolutions.com â†’ www.starworkforcesolutions.com
  if (hostname === "starworkforcesolutions.com") {
    url.host = "www.starworkforcesolutions.com"
    console.log("[WWW REDIRECT]", {
      from: hostname,
      to: "www.starworkforcesolutions.com",
      path: url.pathname,
      timestamp: new Date().toISOString(),
    })
    return NextResponse.redirect(url, 301) // Permanent redirect
  }

  // Rate limiting for API routes
  if (request.nextUrl.pathname.startsWith("/api/")) {
    const ip = request.ip || request.headers.get("x-forwarded-for") || request.headers.get("x-real-ip") || "anonymous"

    // Simple rate limit check (60 requests per minute per IP)
    // For production, consider using Vercel KV or Upstash Redis
    const rateLimitKey = `ratelimit:${ip}`

    // Note: This is a basic implementation. For production scale,
    // use a distributed rate limiter like Vercel KV
  }

  if (isSuspiciousTraffic(request)) {
    console.log("[BOT BLOCKED]", {
      userAgent: request.headers.get("user-agent"),
      url: request.url,
      timestamp: new Date().toISOString(),
    })

    // Return 403 Forbidden for bots
    return new NextResponse("Forbidden", { status: 403 })
  }

  // Log request (Vercel will capture this)
  console.log("[REQUEST]", {
    method: request.method,
    url: request.url,
    timestamp: new Date().toISOString(),
  })

  // Add security headers
  const response = NextResponse.next()

  response.headers.set("X-Content-Type-Options", "nosniff")
  response.headers.set("X-Frame-Options", "DENY")
  response.headers.set("X-XSS-Protection", "1; mode=block")
  response.headers.set("Referrer-Policy", "strict-origin-when-cross-origin")

  // Log response time
  const duration = Date.now() - startTime
  console.log("[RESPONSE]", {
    method: request.method,
    url: request.url,
    duration,
    status: response.status,
    timestamp: new Date().toISOString(),
  })

  return response
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public files (public directory)
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
}

========================================
SECTION 11: DATABASE QUERIES (lib/db.ts)
========================================

--- lib/db.ts ---
import { sql } from "@vercel/postgres"
import process from "process"

// Database utility functions for STAR Workforce Solutions
// Uses Vercel Postgres with connection pooling

export interface User {
  id: string
  name: string | null
  email: string
  emailVerified: Date | null
  role: "jobseeker" | "employer" | "employer-pending" | "admin"
  atsPremium: boolean
  createdAt: Date
}

export interface Job {
  id: string
  employerId: string
  title: string
  description: string
  location: string
  industry: string
  employmentType: "consulting" | "contract"
  visa: string | null
  salaryMin: number | null
  salaryMax: number | null
  expiresAt: Date
  createdAt: Date
  isActive: boolean
}

export interface Payment {
  id: string
  userId: string
  stripeSessionId: string
  amount: number
  product: string
  createdAt: Date
}

export interface Resume {
  id: string
  userId: string
  fileUrl: string
  createdAt: Date
}

// User queries
export async function getUserByEmail(email: string): Promise<User | null> {
  try {
    if (!process.env.DATABASE_URL && !process.env.POSTGRES_URL) {
      console.warn("[v0] Database not configured - getUserByEmail skipped")
      return null
    }

    const result = await sql<User>`
      SELECT * FROM users WHERE email = ${email} LIMIT 1
    `
    return result.rows[0] || null
  } catch (error) {
    console.error("[v0] Error fetching user by email:", error)
    return null
  }
}

export async function getUserById(id: string): Promise<User | null> {
  try {
    if (!process.env.DATABASE_URL && !process.env.POSTGRES_URL) {
      console.warn("[v0] Database not configured - getUserById skipped")
      return null
    }

    const result = await sql<User>`
      SELECT * FROM users WHERE id = ${id} LIMIT 1
    `
    return result.rows[0] || null
  } catch (error) {
    console.error("[v0] Error fetching user by ID:", error)
    return null
  }
}

export async function createUser(data: {
  name?: string
  email: string
  emailVerified?: Date
  role?: string
}): Promise<User | null> {
  try {
    if (!process.env.DATABASE_URL && !process.env.POSTGRES_URL) {
      console.warn("[v0] Database not configured - createUser skipped")
      return null
    }

    const result = await sql<User>`
      INSERT INTO users (name, email, "emailVerified", role)
      VALUES (${data.name || null}, ${data.email}, ${data.emailVerified || null}, ${data.role || "jobseeker"})
      RETURNING *
    `
    return result.rows[0] || null
  } catch (error) {
    console.error("[v0] Error creating user:", error)
    return null
  }
}

export async function updateUserAtsPremium(userId: string, isPremium: boolean): Promise<boolean> {
  try {
    await sql`
      UPDATE users SET "atsPremium" = ${isPremium} WHERE id = ${userId}
    `
    return true
  } catch (error) {
    console.error("[v0] Error updating ATS premium status:", error)
    return false
  }
}

// Job queries
export async function getActiveJobs(filters?: {
  industry?: string
  location?: string
  employmentType?: string
}): Promise<Job[]> {
  try {
    let query = sql<Job>`
      SELECT * FROM jobs WHERE "isActive" = TRUE AND "expiresAt" > NOW()
    `

    if (filters?.industry) {
      query = sql<Job>`${query} AND industry = ${filters.industry}`
    }

    if (filters?.location) {
      query = sql<Job>`${query} AND location ILIKE ${`%${filters.location}%`}`
    }

    if (filters?.employmentType) {
      query = sql<Job>`${query} AND "employmentType" = ${filters.employmentType}`
    }

    query = sql<Job>`${query} ORDER BY "createdAt" DESC LIMIT 50`

    const result = await query
    return result.rows
  } catch (error) {
    console.error("[v0] Error fetching active jobs:", error)
    return []
  }
}

export async function getEmployerActiveJobCount(employerId: string): Promise<number> {
  try {
    const result = await sql`
      SELECT COUNT(*) as count FROM jobs WHERE "employerId" = ${employerId} AND "isActive" = TRUE
    `
    return Number.parseInt(result.rows[0]?.count || "0")
  } catch (error) {
    console.error("[v0] Error counting employer jobs:", error)
    return 0
  }
}

export async function createJob(data: {
  employerId: string
  title: string
  description: string
  location: string
  industry: string
  employmentType: "consulting" | "contract"
  visa?: string
  salaryMin?: number
  salaryMax?: number
}): Promise<Job | null> {
  try {
    const result = await sql<Job>`
      INSERT INTO jobs ("employerId", title, description, location, industry, "employmentType", visa, "salaryMin", "salaryMax")
      VALUES (${data.employerId}, ${data.title}, ${data.description}, ${data.location}, ${data.industry}, ${data.employmentType}, ${data.visa || null}, ${data.salaryMin || null}, ${data.salaryMax || null})
      RETURNING *
    `
    return result.rows[0] || null
  } catch (error) {
    console.error("[v0] Error creating job:", error)
    return null
  }
}

// Payment queries
export async function createPayment(data: {
  userId: string
  stripeSessionId: string
  amount: number
  product: string
}): Promise<Payment | null> {
  try {
    const result = await sql<Payment>`
      INSERT INTO payments ("userId", "stripeSessionId", amount, product)
      VALUES (${data.userId}, ${data.stripeSessionId}, ${data.amount}, ${data.product})
      RETURNING *
    `
    return result.rows[0] || null
  } catch (error) {
    console.error("[v0] Error creating payment:", error)
    return null
  }
}

export async function getPaymentBySessionId(sessionId: string): Promise<Payment | null> {
  try {
    const result = await sql<Payment>`
      SELECT * FROM payments WHERE "stripeSessionId" = ${sessionId} LIMIT 1
    `
    return result.rows[0] || null
  } catch (error) {
    console.error("[v0] Error fetching payment:", error)
    return null
  }
}

// Resume queries
export async function createResume(data: {
  userId: string
  fileUrl: string
}): Promise<Resume | null> {
  try {
    const result = await sql<Resume>`
      INSERT INTO resumes ("userId", "fileUrl")
      VALUES (${data.userId}, ${data.fileUrl})
      RETURNING *
    `
    return result.rows[0] || null
  } catch (error) {
    console.error("[v0] Error creating resume record:", error)
    return null
  }
}

// Utility: Run job expiration
export async function expireOldJobs(): Promise<void> {
  try {
    await sql`SELECT expire_old_jobs()`
  } catch (error) {
    console.error("[v0] Error expiring old jobs:", error)
  }
}

